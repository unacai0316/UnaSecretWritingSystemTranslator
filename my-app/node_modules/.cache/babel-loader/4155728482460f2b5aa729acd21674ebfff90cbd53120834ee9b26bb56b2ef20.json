{"ast":null,"code":"/**\n * Create a unicode character from the codepoint of a Chinese character\n * @param codepoint codepoint of Chinese character as number or string type\n * @example\n * ```\n * codepointToUnicode(0x6211)   // 我\n * codepointToUnicode('0x6211') // 我\n * codepointToUnicode('U+6211') // 我\n * codepointToUnicode('6211')   // 我\n * ```\n */\nexport const codepointToUnicode = codepoint => {\n  if (typeof codepoint === 'string') {\n    let codepointStr = codepoint.replace('U+', '');\n    if (!/^0x/.test(codepointStr)) {\n      codepointStr = '0x' + codepointStr;\n    }\n    return String.fromCodePoint(parseInt(codepointStr));\n  }\n  return String.fromCodePoint(codepoint);\n};\n/**\n * Four tones: ` ̄` ` ́` ` ̌` ` ̀`\n */\nexport const toneMarks = ['\\u0304', '\\u0301', '\\u030c', '\\u0300'];\n/**\n * Returns the tone number of a Pinyin syllable\n * @param text Pinyin syllable to get the tone number from\n * @example\n * ```\n * getToneNumber('shì')  // 4\n * getToneNumber('shi4') // 4\n * ```\n */\nexport const getToneNumber = text => {\n  // Check for tone number\n  const matches = text.match(/[a-zü](\\d)/i);\n  if (matches) return +matches[1];\n  // Check for tone mark\n  for (let i = 0; i < toneMarks.length; i++) {\n    if (text.normalize('NFD').match(toneMarks[i])) return i + 1;\n  }\n  // Return 5th tone as default\n  return 5;\n};\n/**\n * Removes the tone mark/number from a Pinyin syllable\n * @param text Pinyin syllable to remove the tone mark/number from\n * @example\n * ```\n * removeTone('wǒ')  // wo\n * removeTone('wo3') // wo\n * ```\n */\nexport const removeTone = text => {\n  text = text.normalize('NFD').replace(/\\u0304|\\u0301|\\u030c|\\u0300/g, '');\n  return text.normalize('NFC').replace(/(\\w|ü)[1-5]/gi, '$1');\n};\nexport function markToNumber(data, fithTone = true) {\n  const process = text => {\n    if (text.trim().length === 0) return text;\n    if (fithTone) {\n      return removeTone(text) + getToneNumber(text);\n    } else {\n      const tone = getToneNumber(text);\n      return tone === 5 ? removeTone(text) : removeTone(text) + tone;\n    }\n  };\n  if (Array.isArray(data)) {\n    return data.map(process);\n  } else {\n    return process(data);\n  }\n}\nexport function numberToMark(data) {\n  const process = text => {\n    if (text.trim().length === 0) return text;\n    const tone = getToneNumber(text);\n    text = removeTone(text);\n    if (tone !== 5) {\n      if (text === 'm' || text === 'n' || text === 'M' || text === 'N') {\n        return (text + toneMarks[tone - 1]).normalize('NFC');\n      }\n      const matchedVovels = text.match(/[aeiouü]/gi);\n      if (matchedVovels) {\n        let vovel = matchedVovels[matchedVovels.length - 1];\n        if (text.match('ou')) vovel = 'o';\n        if (text.match('a')) vovel = 'a';\n        if (text.match('e')) vovel = 'e';\n        return text.replace(vovel, vovel + toneMarks[tone - 1]).normalize('NFC');\n      }\n    }\n    return text;\n  };\n  if (Array.isArray(data)) {\n    return data.map(process);\n  } else {\n    return process(data);\n  }\n}","map":{"version":3,"names":["codepointToUnicode","codepoint","codepointStr","replace","test","String","fromCodePoint","parseInt","toneMarks","getToneNumber","text","matches","match","i","length","normalize","removeTone","markToNumber","data","fithTone","process","trim","tone","Array","isArray","map","numberToMark","matchedVovels","vovel"],"sources":["/Users/tsaiyunzhen/my-react-app/my-app/node_modules/pinyin-utils/lib/esm/index.js"],"sourcesContent":["/**\n * Create a unicode character from the codepoint of a Chinese character\n * @param codepoint codepoint of Chinese character as number or string type\n * @example\n * ```\n * codepointToUnicode(0x6211)   // 我\n * codepointToUnicode('0x6211') // 我\n * codepointToUnicode('U+6211') // 我\n * codepointToUnicode('6211')   // 我\n * ```\n */\nexport const codepointToUnicode = (codepoint) => {\n    if (typeof codepoint === 'string') {\n        let codepointStr = codepoint.replace('U+', '');\n        if (!/^0x/.test(codepointStr)) {\n            codepointStr = '0x' + codepointStr;\n        }\n        return String.fromCodePoint(parseInt(codepointStr));\n    }\n    return String.fromCodePoint(codepoint);\n};\n/**\n * Four tones: ` ̄` ` ́` ` ̌` ` ̀`\n */\nexport const toneMarks = ['\\u0304', '\\u0301', '\\u030c', '\\u0300'];\n/**\n * Returns the tone number of a Pinyin syllable\n * @param text Pinyin syllable to get the tone number from\n * @example\n * ```\n * getToneNumber('shì')  // 4\n * getToneNumber('shi4') // 4\n * ```\n */\nexport const getToneNumber = (text) => {\n    // Check for tone number\n    const matches = text.match(/[a-zü](\\d)/i);\n    if (matches)\n        return +matches[1];\n    // Check for tone mark\n    for (let i = 0; i < toneMarks.length; i++) {\n        if (text.normalize('NFD').match(toneMarks[i]))\n            return i + 1;\n    }\n    // Return 5th tone as default\n    return 5;\n};\n/**\n * Removes the tone mark/number from a Pinyin syllable\n * @param text Pinyin syllable to remove the tone mark/number from\n * @example\n * ```\n * removeTone('wǒ')  // wo\n * removeTone('wo3') // wo\n * ```\n */\nexport const removeTone = (text) => {\n    text = text.normalize('NFD').replace(/\\u0304|\\u0301|\\u030c|\\u0300/g, '');\n    return text.normalize('NFC').replace(/(\\w|ü)[1-5]/gi, '$1');\n};\nexport function markToNumber(data, fithTone = true) {\n    const process = (text) => {\n        if (text.trim().length === 0)\n            return text;\n        if (fithTone) {\n            return removeTone(text) + getToneNumber(text);\n        }\n        else {\n            const tone = getToneNumber(text);\n            return tone === 5 ? removeTone(text) : removeTone(text) + tone;\n        }\n    };\n    if (Array.isArray(data)) {\n        return data.map(process);\n    }\n    else {\n        return process(data);\n    }\n}\nexport function numberToMark(data) {\n    const process = (text) => {\n        if (text.trim().length === 0)\n            return text;\n        const tone = getToneNumber(text);\n        text = removeTone(text);\n        if (tone !== 5) {\n            if (text === 'm' || text === 'n' || text === 'M' || text === 'N') {\n                return (text + toneMarks[tone - 1]).normalize('NFC');\n            }\n            const matchedVovels = text.match(/[aeiouü]/gi);\n            if (matchedVovels) {\n                let vovel = matchedVovels[matchedVovels.length - 1];\n                if (text.match('ou'))\n                    vovel = 'o';\n                if (text.match('a'))\n                    vovel = 'a';\n                if (text.match('e'))\n                    vovel = 'e';\n                return text.replace(vovel, vovel + toneMarks[tone - 1]).normalize('NFC');\n            }\n        }\n        return text;\n    };\n    if (Array.isArray(data)) {\n        return data.map(process);\n    }\n    else {\n        return process(data);\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}